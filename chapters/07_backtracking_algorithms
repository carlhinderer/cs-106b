-------------------------------------------------
CHAPTER 7 - BACKTRACKING ALGORITHMS
-------------------------------------------------

- Example - Solving a Maze Using Backtracking


    enum directionT { North, East, South, West };
    struct pointT {
        int x, y;
    };


    pointT AdjacentPoint (pointT pt, directionT dir) {
        pointT newpt = pt;
        switch(dir) {
            case North: newpt.y++; break;
            case East:  newpt.x++; break;
            case South: newpt.y--; break;
            case West:  newpt.x--; break;
        }
    }


    bool SolveMaze(pointT pt) {
        if (OutsideMaze(pt)) return true;
        if (IsMarked(pt)) return false;
        MarkSquare(pt);

        for (int i=0; i<4; i++) {
            directionT dir = directionT(i);
            if (!WallExists(pt, dir)) {
                if (SolveMaze(AdjacentPoint(pt, dir))) {
                    return true;
                }
            }
        }

        UnmarkSquare(pt);
        return false;
    }



- Minimax algorithms

    The minimax strategy is used in games to determine which path a player should 
      take by minimizing the maximum score available to your opponent.

    When implementing a minimax algorithm, we must be able to:

      1. Limit the depth of the recursive search
      2. Assign ratings to moves and positions



- Implementing minimax algorithms

    To implement the algorithm while taking our design constraints into consideration,
      we create 2 mutually recursive functions, 'FindBestMove()' and 'EvaluatePosition()'.

      moveT FindBestMove (stateT state, int depth, int & rating);
      int EvaluatePosition (stateT state, int depth);


    The strategy for 'FindBestMove()':

      moveT FindBestMove (stateT state, int depth, int & rating) {
          for (# each possible move or until you find a forced win) {
              # Make the move
              # Evaluate the resulting position, adding 1 to the depth indicator
              # Keep track of the minimum rating so far, along with the corresponding move
              # Retract the move to restore the original state
          }
          # Store the move rating into the reference parameter
          # Return the best move
      }



- Minimax implementation

    moveT FindBestMove (stateT state, int depth, int & rating) {    
        Vector<moveT> moveList;
        GenerateMoveList(state, moveList);
        int nMoves = moveList.size();
        if (nMoves == 0) Error("No moves available");
        moveT bestMove;
        int minRating = WINNING_POSITION + 1;
        for(inti=0;i<nMoves&&minRating!=LOSING_POSITION;i++){
            moveT move = moveList[i];
            MakeMove(state, move);
            int curRating = EvaluatePosition(state, depth + 1);
            if (curRating < minRating) {
                bestMove = move;
                minRating = curRating;
            }
            RetractMove(state, move);
        }
        rating = -minRating;
        return bestMove;
    }

    int EvaluatePosition (stateT state, int depth) {    
        int rating;    
        if (GameIsOver(state) || depth >= MAX_DEPTH) { 
            return EvaluateStaticPosition(state);    
        }
        FindBestMove(state, depth, rating);
        return rating;
    }