-------------------------------------------------
CHAPTER 6 - RECURSIVE PROCEDURES
-------------------------------------------------

- Tower of Hanoi

    The famous puzzle involves 3 spires with 8 gold disks of different sizes
      placed on top of them.  The goal is to stack all the disks on the first
      spire, so that no larger disk is stacked on top of any smaller disk.


    /* Pseudocode Solution 
     *   n = number of disks to move
     *   start, finish, temp = spires
     */

    void MoveTower (int n, char start, char finish, char temp) {
        if (n == 1) {
            # Move a single disk from start to finish
        } else {
            # Move a tower of (n-1) from start to temp
            # Move a single disk from start to finish
            # Move a tower of (n-1) from temp to finish
        }
    }



- Full Solution - Tower of Hanoi


    void MoveSingleDisk (char start, char finish) {
        cout << start << " -> " << finish << endl;
    }

    void MoveTower (int n, char start, char finish, char temp) {
        if (n == 1) {
            MoveSingleDisk(start, finish);
        } else {
            MoveTower(n-1, start, temp, finish);
            MoveSingleDisk(start, finish);
            MoveTower(n-1, start, temp, finish);
        }
    }



- Listing Permutations

    void ListPermutations (string str) {
        RecursivePermute("", str);
    }


    /* Pseudocode */
    void RecursivePermute (string prefix, string rest) {
        if (rest is empty) {
            # Display the prefix string
        } else {
            for (each character in rest) {
                # Add the character to the end of the prefix
                # Remove the character from rest
                # Recursively generate permutations with the updated values for prefix and rest
            }
        }
    }



- Full Solution - Listing Permutations

    void ListPermutations (string str) {
        RecursivePermute("", str);
    }

    void RecursivePermute (string prefix, string rest) {
        if (rest == "") {
            cout << prefix << endl;
        } else {
            for (int i=0; i < rest.length(); i++) {
                string newPrefix = prefix + rest[i];
                string newRest = rest.substr(0, i) + rest.substr(i+1);
                RecursivePermute(newPrefix, newRest);
            }
        }
    }



- Example - Generate a Mondrian-Style Drawing


    /* File: mondrian.cpp
     * ---------------------------
     * This program creates a random line drawing in a style reminiscent of the 
     *   Dutch painter Piet Mondrian.  The picture is generated by recursively
     *   subdividing the canvas into successively smaller rectangles with 
     *   randomly chosen horizontal and vertical lines.
     */

    #include "genlib.h"
    #include "graphics.h"
    #include "random.h"

    const double MIN_AREA = 0.5;
    const double MIN_EDGE = 0.15;

    void SubdivideCanvas (double x, double y, double width, double height);

    int main() {
        InitGraphics();
        Randomize();
        SubdivideCanvas(0, 0, GetWindowWidth(), GetWindowHeight());
        return 0;
    }

    void SubdivideCanvas (double x, double y, double width, double height) {
        if (width * height >= MIN_AREA) {
            if (width > height) {
                double mid = width * RandomReal(MIN_EDGE, 1 - MIN_EDGE);
                MovePen(x + mid, y);
                DrawLine(0, height);
                SubdivideCanvas(x, y, mid, height);
                SubdivideCanvas(x + mid, y, width - mid, height);
            } else {
                double mid = height * RandomReal(MIN_EDGE, 1 - MIN_EDGE);
                MovePen(x, y + mid);
                DrawLine(width, 0);
                SubdivideCanvas(x, y, width, mid);
                SubdivideCanvas(x, y + mid, width, height - mid);
            }
        }
    }



- Tips for solving problems recursively

    1. Devise a strategy that transforms the problem into smaller versions of
         the same problem.

    2. Once you identify a recursive approach, make sure it does not violate any
         conditions imposed by the problem.

    3. When the problems you are trying to solve increase in complexity, the 
         importance of accepting the recursive leap of faith increases.

    4. You can simulate the operation by drawing the stack frames, but it is also
         important to get beyond the skepticism that causes you to do this.

    5. Wrapper functions are useful in complex recursive procedures.